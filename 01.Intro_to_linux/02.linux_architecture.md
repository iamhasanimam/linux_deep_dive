# Linux Architecture

Linux is a modular operating system. Each layer contributes to making the system reliable, performant, and scalable. Below, we explore each architectural component with a real-world example to tie theory with practice.

+-------------------------+
| User Applications       | 🧑‍💻 (Top layer: Firefox, Vim, Python, systemctl)
+-------------------------+
| Shell / CLI             | 💻 (bash, zsh, fish)
+-------------------------+
| System Libraries        | 📚 (glibc, OpenSSL, system APIs)
+-------------------------+
| User Space Processes    | 👤 (cron, sshd, journald, Docker daemon)
+-------------------------+
| Kernel Space            | 🧠 (Process scheduler, VFS, Memory manager, Device drivers)
+-------------------------+
| Hardware                | ⚙️ (CPU, RAM, Disks, NICs, Peripherals)
+-------------------------+



1. 🧩 Hardware Laye

🔍 Description



This is the physical layer — the actual CPU, RAM, storage, network interfaces, etc.

📌 Key Components

CPU (Intel, AMD, ARM)

RAM

Hard drives / SSDs

NICs (Network Interface Cards)

BIOS/UEFI

🧪 Real-World Example

When you press the power button, the BIOS performs POST (Power-On Self Test) and then hands off to the bootloader.

lscpu         # Shows CPU info
lsblk         # Lists block storage devices

2. 🧠 Kernel Space

🔍 Description

The kernel is the core brain of Linux. It runs in ring 0 and handles all communication between software and hardware.

📌 Key Subsystems

Process Scheduler — Determines which process runs next

Memory Manager — Handles virtual memory, paging

Device Drivers — Talks to physical devices

VFS (Virtual File System) — Abstraction for file systems

Network Stack — Implements TCP/IP

Syscall Interface — Gate to transition from user space to kernel

🧪 Real-World Example

When you run:

echo "hello" > file.txt

It invokes a syscall to open the file and write data. The syscall transitions to kernel space to interact with the file system.

strace echo "hello" > file.txt

This shows the actual syscalls made.

3. 🔁 Init System (PID 1)

🔍 Description

The first process the kernel starts in user space. It manages all system services.

📌 Common Init Systems

systemd (modern)

SysVinit (legacy)

Upstart (Ubuntu legacy)

Responsibilities

Mount disks

Start daemons (like sshd, cron)

Manage runlevels/targets

🧪 Real-World Example

systemctl list-units --type=service

To check system boot logs:

journalctl -b

4. 📚 System Libraries

🔍 Description

Libraries wrap system calls and provide APIs to user applications.

📌 Examples

glibc — GNU C Library

libm — Math

libssl — SSL/TLS

libc.so — Core shared C library

🧪 Real-World Example

Running a C program with printf() internally uses glibc, which calls write() syscall.

printf("Hello\n"); // -> glibc -> write() syscall -> kernel

To inspect which libraries a binary uses:

ldd /bin/ls

5. 👤 User Space Daemons & Services

🔍 Description

These are background services managed by init/systemd.

📌 Examples

sshd — SSH access

cron — Scheduled jobs

rsyslogd — Log management

dbus-daemon — Inter-process communication

🧪 Real-World Example

To see if SSH service is running:

systemctl status sshd

To enable a service:

systemctl enable cron

6. 💻 Shell / Terminal

🔍 Description

Interface to interact with the OS using commands.

📌 Examples

bash

zsh

fish

Responsibilities

Command parsing

Script execution

Environment variable handling

🧪 Real-World Example

echo $HOME
cd /etc && ls -l

This is the shell parsing and executing commands sequentially.

7. 🧑‍💻 User Applications

🔍 Description

User-facing programs like text editors, browsers, compilers, etc.

📌 Examples

vim, nano

gcc, python

firefox, curl

🧪 Real-World Example

Running a script in Python:

python3 script.py

Python interprets the file, makes syscalls via glibc, and gets resources managed by the kernel.

🧪 Debugging Tip

Use this table to map problems to their architectural layer:

Symptom

Layer

Boot hangs

Init or Kernel

Service won’t start

systemd or Daemon

Command not found

Shell

High CPU

User-space process or scheduler

Disk read error

Kernel (VFS or driver)

✅ Final Thoughts

Understanding each layer helps you troubleshoot, optimize, and design robust Linux-based systems. This is non-negotiable for DevOps, Cloud, and SRE roles.

Would you like me to continue with diagrams, bootloader flow, or expand specific sections like kernel internals or systemd targets?

