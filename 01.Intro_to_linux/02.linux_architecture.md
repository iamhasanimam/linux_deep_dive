# Linux Architecture

Linux is a modular operating system. Each layer contributes to making the system reliable, performant, and scalable. Below, we explore each architectural component with a real-world example to tie theory with practice.

+-------------------------+
| User Applications       | ğŸ§‘â€ğŸ’» (Top layer: Firefox, Vim, Python, systemctl)
+-------------------------+
| Shell / CLI             | ğŸ’» (bash, zsh, fish)
+-------------------------+
| System Libraries        | ğŸ“š (glibc, OpenSSL, system APIs)
+-------------------------+
| User Space Processes    | ğŸ‘¤ (cron, sshd, journald, Docker daemon)
+-------------------------+
| Kernel Space            | ğŸ§  (Process scheduler, VFS, Memory manager, Device drivers)
+-------------------------+
| Hardware                | âš™ï¸ (CPU, RAM, Disks, NICs, Peripherals)
+-------------------------+



1. ğŸ§© Hardware Laye

ğŸ” Description



This is the physical layer â€” the actual CPU, RAM, storage, network interfaces, etc.

ğŸ“Œ Key Components

CPU (Intel, AMD, ARM)

RAM

Hard drives / SSDs

NICs (Network Interface Cards)

BIOS/UEFI

ğŸ§ª Real-World Example

When you press the power button, the BIOS performs POST (Power-On Self Test) and then hands off to the bootloader.

lscpu         # Shows CPU info
lsblk         # Lists block storage devices

2. ğŸ§  Kernel Space

ğŸ” Description

The kernel is the core brain of Linux. It runs in ring 0 and handles all communication between software and hardware.

ğŸ“Œ Key Subsystems

Process Scheduler â€” Determines which process runs next

Memory Manager â€” Handles virtual memory, paging

Device Drivers â€” Talks to physical devices

VFS (Virtual File System) â€” Abstraction for file systems

Network Stack â€” Implements TCP/IP

Syscall Interface â€” Gate to transition from user space to kernel

ğŸ§ª Real-World Example

When you run:

echo "hello" > file.txt

It invokes a syscall to open the file and write data. The syscall transitions to kernel space to interact with the file system.

strace echo "hello" > file.txt

This shows the actual syscalls made.

3. ğŸ” Init System (PID 1)

ğŸ” Description

The first process the kernel starts in user space. It manages all system services.

ğŸ“Œ Common Init Systems

systemd (modern)

SysVinit (legacy)

Upstart (Ubuntu legacy)

Responsibilities

Mount disks

Start daemons (like sshd, cron)

Manage runlevels/targets

ğŸ§ª Real-World Example

systemctl list-units --type=service

To check system boot logs:

journalctl -b

4. ğŸ“š System Libraries

ğŸ” Description

Libraries wrap system calls and provide APIs to user applications.

ğŸ“Œ Examples

glibc â€” GNU C Library

libm â€” Math

libssl â€” SSL/TLS

libc.so â€” Core shared C library

ğŸ§ª Real-World Example

Running a C program with printf() internally uses glibc, which calls write() syscall.

printf("Hello\n"); // -> glibc -> write() syscall -> kernel

To inspect which libraries a binary uses:

ldd /bin/ls

5. ğŸ‘¤ User Space Daemons & Services

ğŸ” Description

These are background services managed by init/systemd.

ğŸ“Œ Examples

sshd â€” SSH access

cron â€” Scheduled jobs

rsyslogd â€” Log management

dbus-daemon â€” Inter-process communication

ğŸ§ª Real-World Example

To see if SSH service is running:

systemctl status sshd

To enable a service:

systemctl enable cron

6. ğŸ’» Shell / Terminal

ğŸ” Description

Interface to interact with the OS using commands.

ğŸ“Œ Examples

bash

zsh

fish

Responsibilities

Command parsing

Script execution

Environment variable handling

ğŸ§ª Real-World Example

echo $HOME
cd /etc && ls -l

This is the shell parsing and executing commands sequentially.

7. ğŸ§‘â€ğŸ’» User Applications

ğŸ” Description

User-facing programs like text editors, browsers, compilers, etc.

ğŸ“Œ Examples

vim, nano

gcc, python

firefox, curl

ğŸ§ª Real-World Example

Running a script in Python:

python3 script.py

Python interprets the file, makes syscalls via glibc, and gets resources managed by the kernel.

ğŸ§ª Debugging Tip

Use this table to map problems to their architectural layer:

Symptom

Layer

Boot hangs

Init or Kernel

Service wonâ€™t start

systemd or Daemon

Command not found

Shell

High CPU

User-space process or scheduler

Disk read error

Kernel (VFS or driver)

âœ… Final Thoughts

Understanding each layer helps you troubleshoot, optimize, and design robust Linux-based systems. This is non-negotiable for DevOps, Cloud, and SRE roles.

Would you like me to continue with diagrams, bootloader flow, or expand specific sections like kernel internals or systemd targets?

